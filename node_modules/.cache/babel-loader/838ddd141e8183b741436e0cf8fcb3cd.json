{"ast":null,"code":"var _jsxFileName = \"/home/kathryn/Projects/portfolio/src/utilities/HtmlStringParser.js\";\nimport React from 'react'; // The HtmlStringParser converts a string to a <p></p> containing text and links.  \n// It accepts a htmlString argument comprising one or more iterations of the pattern: stringLink [url] {linkText} with the url enclosed in [] and the linkText enclosed in {}.\n// The parser assigns each iteration to an object in the paraComponents array which is then mapped to create a variable containing strings and <a> tags. The parser can process multiple text and links from one htmlString argument. It can have trailing text and / or begin with a link.\n// Example htmlString: This is example text with [https://fakeurl.com]{some link text}\n// The parser has been tested for:\n// - mulitple links: text[url]{link text}text[url]{link text} etc\n// - trailing text: text[url]{link text}text\n// - starting with a link: [url]{link text}text\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function HtmlStringParser(htmlString) {\n  const string = htmlString;\n  let paraComponents = [];\n\n  if (!string.includes(\"[\")) {\n    return /*#__PURE__*/_jsxDEV(\"p\", {\n      children: string\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 10\n    }, this);\n  } else {\n    let fromIndex = 0;\n\n    function findIndex(char, fromIndex) {\n      return string.indexOf(char, fromIndex);\n    }\n\n    do {\n      let paraComponent = {}; //find the indexes that start and end the url and text for the links\n\n      const startUrlIndex = findIndex(\"[\", fromIndex) + 1;\n      const endUrlIndex = findIndex(\"]\", fromIndex);\n      const startLinkTextIndex = findIndex(\"{\", fromIndex) + 1;\n      const endLinkTextIndex = findIndex(\"}\", fromIndex); // use the indexes above to create variables for the paragraph text, the link url and the link text.\n\n      const paraText = string.slice(fromIndex, startUrlIndex - 1);\n      const linkUrl = string.slice(startUrlIndex, endUrlIndex);\n      const linkText = string.slice(startLinkTextIndex, endLinkTextIndex); // assign them to paraComponent\n\n      paraComponent = {\n        fromIndex: fromIndex,\n        paraText: paraText,\n        linkUrl: linkUrl,\n        linkText: linkText\n      }; // assign the paraComponent object to the paraComponents array\n\n      paraComponents.push(paraComponent); // update the fromIndex so we can process the next chunk\n\n      fromIndex = endLinkTextIndex + 1;\n    } while (fromIndex < string.length && string.includes(\"[\", fromIndex)); // abridged process for any text after the final link:\n\n\n    if (fromIndex < string.length) {\n      let paraComponent = {};\n      const paraText = string.slice(fromIndex);\n      paraComponent = {\n        fromIndex: fromIndex,\n        paraText: paraText,\n        linkUrl: \"\",\n        linkText: \"\"\n      };\n      paraComponents.push(paraComponent);\n    } //return compiled paragraph\n\n\n    let contents = paraComponents.map(component => /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: [component.paraText, \" \", /*#__PURE__*/_jsxDEV(\"a\", {\n        href: component.linkUrl,\n        target: \"_blank\",\n        rel: \"noreferrer\",\n        children: component.linkText\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 85,\n        columnNumber: 67\n      }, this)]\n    }, component.fromIndex, true, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 4\n    }, this));\n    return /*#__PURE__*/_jsxDEV(\"p\", {\n      children: contents\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 88,\n      columnNumber: 10\n    }, this);\n  }\n}\n_c = HtmlStringParser;\n\nvar _c;\n\n$RefreshReg$(_c, \"HtmlStringParser\");","map":{"version":3,"names":["React","HtmlStringParser","htmlString","string","paraComponents","includes","fromIndex","findIndex","char","indexOf","paraComponent","startUrlIndex","endUrlIndex","startLinkTextIndex","endLinkTextIndex","paraText","slice","linkUrl","linkText","push","length","contents","map","component"],"sources":["/home/kathryn/Projects/portfolio/src/utilities/HtmlStringParser.js"],"sourcesContent":["import React from 'react'\n\n// The HtmlStringParser converts a string to a <p></p> containing text and links.  \n// It accepts a htmlString argument comprising one or more iterations of the pattern: stringLink [url] {linkText} with the url enclosed in [] and the linkText enclosed in {}.\n// The parser assigns each iteration to an object in the paraComponents array which is then mapped to create a variable containing strings and <a> tags. The parser can process multiple text and links from one htmlString argument. It can have trailing text and / or begin with a link.\n\n// Example htmlString: This is example text with [https://fakeurl.com]{some link text}\n\n// The parser has been tested for:\n// - mulitple links: text[url]{link text}text[url]{link text} etc\n// - trailing text: text[url]{link text}text\n// - starting with a link: [url]{link text}text\n\n\n\nexport default function HtmlStringParser(htmlString){\n\n\tconst string = htmlString\n\n\tlet paraComponents = []\n\n\n\tif(!string.includes(\"[\")){\n\t\treturn <p>{string}</p>\n\t}else{\n\t\tlet fromIndex = 0\n\n\t\tfunction findIndex (char, fromIndex){\n\t\t\treturn string.indexOf(char, fromIndex)\n\t\t}\n\n\t\tdo{\n\t\t\tlet paraComponent = {}\n\n\t\t\t//find the indexes that start and end the url and text for the links\n\t\t\tconst startUrlIndex = findIndex(\"[\", fromIndex) + 1\n\t\t\tconst endUrlIndex = findIndex(\"]\", fromIndex)\n\t\t\tconst startLinkTextIndex = findIndex(\"{\", fromIndex) + 1\n\t\t\tconst endLinkTextIndex = findIndex(\"}\", fromIndex)\n\n\n\t\t\t// use the indexes above to create variables for the paragraph text, the link url and the link text.\n\t\t\tconst paraText = string.slice(fromIndex, startUrlIndex - 1)\n\t\t\tconst linkUrl = string.slice(startUrlIndex, endUrlIndex)\n\t\t\tconst linkText = string.slice(startLinkTextIndex, endLinkTextIndex)\n\n\t\t\t// assign them to paraComponent\n\t\t\tparaComponent = {\n\t\t\t\tfromIndex: fromIndex,\n\t\t\t\tparaText: paraText,\n\t\t\t\tlinkUrl: linkUrl,\n\t\t\t\tlinkText: linkText\n\t\t\t}\n\n\t\t\t// assign the paraComponent object to the paraComponents array\n\t\t\tparaComponents.push(paraComponent)\n\n\t\t\t// update the fromIndex so we can process the next chunk\n\t\t\tfromIndex = endLinkTextIndex + 1\n\n\n\t\t} while ( fromIndex < string.length && string.includes(\"[\", fromIndex) )\n\n\t\t// abridged process for any text after the final link:\n\t\tif( fromIndex < string.length){\n\n\n\t\t\tlet paraComponent = {}\n\t\t\tconst paraText = string.slice(fromIndex)\n\n\t\t\tparaComponent = {\n\t\t\t\tfromIndex: fromIndex,\n\t\t\t\tparaText: paraText,\n\t\t\t\tlinkUrl: \"\",\n\t\t\t\tlinkText: \"\"\n\t\t\t}\n\t\t\t\n\t\t\tparaComponents.push(paraComponent)\n\t\t}\n\n\n\t\t//return compiled paragraph\n\n\t\tlet contents = paraComponents.map(component => (\n\t\t\t<React.Fragment key={component.fromIndex}>{component.paraText} <a href={component.linkUrl} target=\"_blank\" rel=\"noreferrer\">{component.linkText}</a></React.Fragment>\n\t\t))\n\n\t\treturn <p>{contents}</p>\n\t}\n}\n"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;;AAIA,eAAe,SAASC,gBAAT,CAA0BC,UAA1B,EAAqC;EAEnD,MAAMC,MAAM,GAAGD,UAAf;EAEA,IAAIE,cAAc,GAAG,EAArB;;EAGA,IAAG,CAACD,MAAM,CAACE,QAAP,CAAgB,GAAhB,CAAJ,EAAyB;IACxB,oBAAO;MAAA,UAAIF;IAAJ;MAAA;MAAA;MAAA;IAAA,QAAP;EACA,CAFD,MAEK;IACJ,IAAIG,SAAS,GAAG,CAAhB;;IAEA,SAASC,SAAT,CAAoBC,IAApB,EAA0BF,SAA1B,EAAoC;MACnC,OAAOH,MAAM,CAACM,OAAP,CAAeD,IAAf,EAAqBF,SAArB,CAAP;IACA;;IAED,GAAE;MACD,IAAII,aAAa,GAAG,EAApB,CADC,CAGD;;MACA,MAAMC,aAAa,GAAGJ,SAAS,CAAC,GAAD,EAAMD,SAAN,CAAT,GAA4B,CAAlD;MACA,MAAMM,WAAW,GAAGL,SAAS,CAAC,GAAD,EAAMD,SAAN,CAA7B;MACA,MAAMO,kBAAkB,GAAGN,SAAS,CAAC,GAAD,EAAMD,SAAN,CAAT,GAA4B,CAAvD;MACA,MAAMQ,gBAAgB,GAAGP,SAAS,CAAC,GAAD,EAAMD,SAAN,CAAlC,CAPC,CAUD;;MACA,MAAMS,QAAQ,GAAGZ,MAAM,CAACa,KAAP,CAAaV,SAAb,EAAwBK,aAAa,GAAG,CAAxC,CAAjB;MACA,MAAMM,OAAO,GAAGd,MAAM,CAACa,KAAP,CAAaL,aAAb,EAA4BC,WAA5B,CAAhB;MACA,MAAMM,QAAQ,GAAGf,MAAM,CAACa,KAAP,CAAaH,kBAAb,EAAiCC,gBAAjC,CAAjB,CAbC,CAeD;;MACAJ,aAAa,GAAG;QACfJ,SAAS,EAAEA,SADI;QAEfS,QAAQ,EAAEA,QAFK;QAGfE,OAAO,EAAEA,OAHM;QAIfC,QAAQ,EAAEA;MAJK,CAAhB,CAhBC,CAuBD;;MACAd,cAAc,CAACe,IAAf,CAAoBT,aAApB,EAxBC,CA0BD;;MACAJ,SAAS,GAAGQ,gBAAgB,GAAG,CAA/B;IAGA,CA9BD,QA8BUR,SAAS,GAAGH,MAAM,CAACiB,MAAnB,IAA6BjB,MAAM,CAACE,QAAP,CAAgB,GAAhB,EAAqBC,SAArB,CA9BvC,EAPI,CAuCJ;;;IACA,IAAIA,SAAS,GAAGH,MAAM,CAACiB,MAAvB,EAA8B;MAG7B,IAAIV,aAAa,GAAG,EAApB;MACA,MAAMK,QAAQ,GAAGZ,MAAM,CAACa,KAAP,CAAaV,SAAb,CAAjB;MAEAI,aAAa,GAAG;QACfJ,SAAS,EAAEA,SADI;QAEfS,QAAQ,EAAEA,QAFK;QAGfE,OAAO,EAAE,EAHM;QAIfC,QAAQ,EAAE;MAJK,CAAhB;MAOAd,cAAc,CAACe,IAAf,CAAoBT,aAApB;IACA,CAtDG,CAyDJ;;;IAEA,IAAIW,QAAQ,GAAGjB,cAAc,CAACkB,GAAf,CAAmBC,SAAS,iBAC1C,QAAC,KAAD,CAAO,QAAP;MAAA,WAA2CA,SAAS,CAACR,QAArD,oBAA+D;QAAG,IAAI,EAAEQ,SAAS,CAACN,OAAnB;QAA4B,MAAM,EAAC,QAAnC;QAA4C,GAAG,EAAC,YAAhD;QAAA,UAA8DM,SAAS,CAACL;MAAxE;QAAA;QAAA;QAAA;MAAA,QAA/D;IAAA,GAAqBK,SAAS,CAACjB,SAA/B;MAAA;MAAA;MAAA;IAAA,QADc,CAAf;IAIA,oBAAO;MAAA,UAAIe;IAAJ;MAAA;MAAA;MAAA;IAAA,QAAP;EACA;AACD;KA1EuBpB,gB"},"metadata":{},"sourceType":"module"}